#!/usr/bin/env python

# Used to store the last mapped point cloud
import rospy
from sensor_msgs.msg import PointCloud2, Image
from std_msgs.msg import String, Float64
from drone_ros_msgs.msg import PlanesInliers, PlanesInliersArr
import numpy as np
import sys
import rospkg

import matplotlib.pyplot as plt

import numpy as np
from tf.transformations import quaternion_from_euler as q_e
from tf.transformations import euler_from_quaternion as e_q
from geometry_msgs.msg import Point, Polygon, Vector3
from visualization_msgs.msg import Marker
from drone_ros_msgs.msg import Planes
from PyKDL import *
import PyKDL
import numpy.linalg as LA
import rospy
import ros_numpy
import time
import tf
import tf2_ros
import tf2_geometry_msgs
from scipy.spatial import ConvexHull
import scipy.ndimage as ndimage

# https://gis.stackexchange.com/questions/22895/finding-minimum-area-rectangle-for-given-points
def minimum_bounding_rectangle(points):
    """
    Find the smallest bounding rectangle for a set of points.
    Returns a set of points representing the corners of the bounding box.

    :param points: an nx2 matrix of coordinates
    :rval: an nx2 matrix of coordinates
    """
    from scipy.ndimage.interpolation import rotate
    pi2 = np.pi/2.

    # get the convex hull for the points
    hull_points = points[ConvexHull(points).vertices]

    # calculate edge angles
    edges = np.zeros((len(hull_points)-1, 2))
    edges = hull_points[1:] - hull_points[:-1]

    angles = np.zeros((len(edges)))
    angles = np.arctan2(edges[:, 1], edges[:, 0])

    angles = np.abs(np.mod(angles, pi2))
    angles = np.unique(angles)

    # find rotation matrices
    # XXX both work
    rotations = np.vstack([
        np.cos(angles),
        np.cos(angles-pi2),
        np.cos(angles+pi2),
        np.cos(angles)]).T
#     rotations = np.vstack([
#         np.cos(angles),
#         -np.sin(angles),
#         np.sin(angles),
#         np.cos(angles)]).T
    rotations = rotations.reshape((-1, 2, 2))

    # apply rotations to the hull
    rot_points = np.dot(rotations, hull_points.T)

    # find the bounding points
    min_x = np.nanmin(rot_points[:, 0], axis=1)
    max_x = np.nanmax(rot_points[:, 0], axis=1)
    min_y = np.nanmin(rot_points[:, 1], axis=1)
    max_y = np.nanmax(rot_points[:, 1], axis=1)

    # find the box with the best area
    areas = (max_x - min_x) * (max_y - min_y)
    best_idx = np.argmin(areas)

    # return the best box
    x1 = max_x[best_idx]
    x2 = min_x[best_idx]
    y1 = max_y[best_idx]
    y2 = min_y[best_idx]
    r = rotations[best_idx]

    rval = np.zeros((4, 2))
    rval[0] = np.dot([x1, y2], r)
    rval[1] = np.dot([x2, y2], r)
    rval[2] = np.dot([x2, y1], r)
    rval[3] = np.dot([x1, y1], r)

    return rval

# â€‹
# #https://stackoverflow.com/questions/35070178/fit-plane-to-a-set-of-points-in-3d-scipy-optimize-minimize-vs-scipy-linalg-lsts
def publish_plane(p1,p2,p3,p4,ns,planes):
    global marker_pub, plane_pub    
    pp1=Point(p1[0],p1[1],p1[2])
    pp2=Point(p2[0],p2[1],p2[2])
    pp3=Point(p3[0],p3[1],p3[2])
    pp4=Point(p4[0],p4[1],p4[2])
    m = Marker()
    m.ns = "points"+chr(ns)
    m.header.frame_id="panda_link0"
    m.type = 8
    m.points=[pp1,pp2,pp3,pp4]
    m.scale.x=.01
    m.scale.y=.01
    m.color.a=.8
    m.color.r = 1.0
    marker_pub.publish(m)
    rospy.sleep(rospy.Duration(0, 100))

    # barycenter of the points
    # compute centered coordinates
    coords = np.array([p1,p2,p3,p4])
    G = coords.sum(axis=0) / coords.shape[0]
    # print(G)
    # run SVD
    u, s, v = np.linalg.svd(coords - G)
    v[2]=np.sign(np.cross(v[0],v[1]).dot(v[2]))*v[2]

    norm = Point(v[2,0],v[2,1],v[2,2])

    planes.header.frame_id = "panda_link0"
    poly = Polygon()
    poly.points = [pp1,pp2,pp3,pp4]
    #plane_pub.publish(planes)
    rp1=v.dot(p1)#rotate(R,p1)
    rp2=v.dot(p2)#rotate(R,p2)
    rp3=v.dot(p3)#rotate(R,p3)
    xs=[rp1[0],rp2[0],rp3[0]]
    ys=[rp1[1],rp2[1],rp3[1]]
    zs=[rp1[2],rp2[2],rp3[2]]
    q=Rotation(v[0,0],v[0,1],v[0,2],v[1,0],v[1,1],v[1,2],v[2,0],v[2,1],v[2,2]).Inverse().GetQuaternion()

    # unitary normal vector
    m = Marker()
    m.header.frame_id="panda_link0"
    m.ns=chr(ns)
    m.type = 1
    m.pose.orientation.x = q[0]
    m.pose.orientation.y = q[1]
    m.pose.orientation.z = q[2]
    m.pose.orientation.w = q[3]
    m.pose.position.x=G[0]
    m.pose.position.y=G[1]
    m.pose.position.z=G[2]
    m.scale.x=s[0]#max(xs)-min(xs)
    m.scale.y=s[1]#max(ys)-min(ys)
    m.scale.z=s[2]#max(zs)-min(zs)
    # print(m.scale.z)
    m.color.a=.9
    m.color.r=250
    m.color.g=250
    m.color.b=250
    marker_pub.publish(m)
    planes.planes.append(poly)
    planes.normals.append(norm)
    half_axe = Vector3(s[0]/2,s[1]/2,s[2]/2)
    planes.half_axes.append(half_axe)
    planes.poses.append(m.pose)
    rospy.sleep(rospy.Duration(0, 100))

def processPlanes(data):
    planes = Planes()
    for ii in range(0,len(data.planes)):
        # plane parameters
        a = data.planes[ii].a.data
        b = data.planes[ii].b.data
        c = data.planes[ii].c.data
        d = data.planes[ii].d.data

        # Get Data from plane
        x = np.array(data.planes[ii].x.data)
        x = x.reshape((len(x),1))
        y = np.array(data.planes[ii].y.data)
        y = y.reshape((len(y),1))
        z = np.array(data.planes[ii].z.data)
        z = z.reshape((len(z),1))
        plane_pts = np.concatenate((x,y,z),axis=1)

        # print(np.shape(plane_pts))

        # Define plane axes for projection
        plane_normal = np.array([a,b,c])
        # print("NORMAL:",plane_normal)
        if abs(np.dot(plane_normal,np.array([1.0, 0.0, 0.0])))<0.95:
            dir_plane_x = np.array([1.0, 0.0, 0.0])
        else:
            dir_plane_x = np.array([0.0, 1.0, 0.0])

        dir_plane_x = dir_plane_x-np.dot(plane_normal,dir_plane_x)*plane_normal
        dir_plane_x = dir_plane_x/np.linalg.norm(dir_plane_x)

        dir_plane_y = -np.cross(dir_plane_x,plane_normal)

        rot = np.hstack((dir_plane_x.reshape((3,1)),dir_plane_y.reshape((3,1)),plane_normal.reshape((3,1))))

        # print("ROT: \n",rot)

        # Project onto plane
        plane_pts_rot = (rot.T @ plane_pts.T).T

        # Binary erosion
        x_inds = np.digitize(plane_pts_rot[:,0],np.linspace(np.min(plane_pts_rot[:,0]),np.max(plane_pts_rot[:,0]),99))
        y_inds = np.digitize(plane_pts_rot[:,1],np.linspace(np.min(plane_pts_rot[:,1]),np.max(plane_pts_rot[:,1]),99))

        bin_image = np.zeros((100,100), dtype=np.int)
        for ii in range(0,len(plane_pts_rot[:,0])):
            bin_image[x_inds[ii],y_inds[ii]]=1

        bin_image = ndimage.binary_erosion(bin_image).astype(bin_image.dtype)

        inds_post_erosion = np.nonzero(bin_image)
        eroded_pts = np.zeros((len(inds_post_erosion[0]),2))
        for ii in range(0,len(inds_post_erosion[0])):
            eroded_pts[ii,0] = np.linspace(np.min(plane_pts_rot[:,0]),np.max(plane_pts_rot[:,0]),99)[inds_post_erosion[0][ii]]
            eroded_pts[ii,1] = np.linspace(np.min(plane_pts_rot[:,1]),np.max(plane_pts_rot[:,1]),99)[inds_post_erosion[1][ii]]


        # Calculate rectangle
        rect_verts = minimum_bounding_rectangle(eroded_pts[:,:])
        # print(rect_verts)
       

        # print(np.average(plane_pts[:,2]))
        # print(np.std(plane_pts[:,2]))
        z_plane = np.average(plane_pts_rot[:,2])
        
        # Project points back into 3D
        rect_verts_3d = np.hstack((rect_verts,z_plane*np.ones((4,1))))
        verts_orig = (rot @ rect_verts_3d.T)

        # print(verts_orig)

        publish_plane(verts_orig[:,0],verts_orig[:,1],verts_orig[:,2],verts_orig[:,3],ii,planes)
    
    # send to IK
    plane_pub.publish(planes)

def listenForPlanes():
    global marker_pub, plane_pub
    rospy.init_node('plane_to_bounding')
    rospy.Subscriber("/pclplanes", PlanesInliersArr, processPlanes)
    marker_pub = rospy.Publisher("/viz/meshes",Marker,queue_size = 1,latch =False)
    plane_pub = rospy.Publisher("/panda_ik/planes",Planes,queue_size = 1,latch =False)
    rospy.spin()


if __name__ == '__main__':
    listenForPlanes()


